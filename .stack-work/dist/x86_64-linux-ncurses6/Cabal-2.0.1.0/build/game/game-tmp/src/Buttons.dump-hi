
==================== FINAL INTERFACE ====================
2018-06-05 00:36:03.642966045 UTC

interface main:Buttons 8022
  interface hash: 19ddfa57125dfb04647d57958ea96c26
  ABI hash: eb5ee8bed5c3803d702090bd75709be5
  export-list hash: 2f3907c0af37ac9fc752c2492d57e9d5
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: c3d080cdf3a45f880096629af0ba9355
  sig of: Nothing
  used TH splices: False
  where
exports:
  Buttons.alignToBottomEdgeButtonAttr
  Buttons.alignToLeftEdgeButtonAttr
  Buttons.alignToRightEdgeButtonAttr
  Buttons.createButtonAttrFromAabb
  Buttons.createButtonAttrFromRectangle
  Buttons.createCenteredButtonAttr
  Buttons.createLeftEdgeAlignedButtonAttr
  Buttons.createRightEdgeAlignedButtonAttr
  Buttons.createXCenteredButtonAttr
  Buttons.translateButtonAttr
  Buttons.xCenterButtonAttr
  Buttons.yCenterButtonAttr
  Buttons.Button
  Buttons.ButtonAttr{Buttons.ButtonAttr aabb rect texture}
module dependencies: Aabb Animations GameVars GuiTransforms Logger
                     TimeManager Util Walls
package dependencies: QuickCheck-2.10.1 Stack-0.3.2
                      StateVar-1.1.1.0 Stream-0.4.7.2 adjunctions-4.4 array-0.5.2.0
                      base-4.10.1.0 base-orphans-0.7 bifunctors-5.5.2 binary-0.8.5.1
                      bytes-0.15.4 bytestring-0.10.8.2 call-stack-0.1.0 cereal-0.5.5.0
                      clock-0.7.2 comonad-5.0.3 containers-0.5.10.2 contravariant-1.4.1
                      data-default-class-0.1.2.0 deepseq-1.4.3.0 distributive-0.5.3
                      exceptions-0.8.3 free-5.0.2 ghc-boot-th-8.2.2 ghc-prim-0.5.1.1
                      hashable-1.2.7.0 integer-gmp-1.0.1.0 integer-logarithms-1.0.2.1
                      kan-extensions-5.1 lazysmallcheck-0.6 lens-4.16.1
                      lifted-base-0.2.3.12 linear-1.20.7 monad-control-1.0.2.3 mtl-2.2.2
                      pretty-1.1.3.3 primitive-0.6.3.0 profunctors-5.2.2 random-1.1
                      reflection-2.1.3 scientific-0.3.6.0 sdl2-2.4.0.1 sdl2-mixer-1.1.0
                      sdl2-ttf-2.0.2 semigroupoids-5.2.2 stm-2.4.5.0 tagged-0.8.5
                      template-haskell-2.12.0.0 text-1.2.3.0 tf-random-0.5
                      th-abstraction-0.2.6.0 time-1.8.0.2 transformers-0.5.2.0
                      transformers-base-0.4.4 transformers-compat-0.5.1.4
                      unordered-containers-0.2.9.0 vector-0.12.0.1
orphans: time-1.8.0.2:Data.Time.Clock.TAI
         reflection-2.1.3:Data.Reflection
         vector-0.12.0.1:Data.Vector.Unboxed
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.0:Data.Text.Lazy
         linear-1.20.7:Linear.Instances base-orphans-0.7:Data.Orphans
         text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         text-1.2.3.0:Data.Text.Show
         bytestring-0.10.8.2:Data.ByteString.Builder
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         stm-2.4.5.0:Control.Monad.STM time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         transformers-0.5.2.0:Control.Monad.Trans.Error
         base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: adjunctions-4.4:Data.Functor.Rep
                         base-4.10.1.0:Control.Applicative base-4.10.1.0:Data.Complex
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Compose
                         base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats bifunctors-5.5.2:Data.Bifunctor.Biff
                         bifunctors-5.5.2:Data.Bifunctor.Clown
                         bifunctors-5.5.2:Data.Bifunctor.Fix
                         bifunctors-5.5.2:Data.Bifunctor.Flip
                         bifunctors-5.5.2:Data.Bifunctor.Join
                         bifunctors-5.5.2:Data.Bifunctor.Joker
                         bifunctors-5.5.2:Data.Bifunctor.Product
                         bifunctors-5.5.2:Data.Bifunctor.Sum
                         bifunctors-5.5.2:Data.Bifunctor.Tannen
                         bifunctors-5.5.2:Data.Bifunctor.Wrapped bytes-0.15.4:Data.Bytes.Get
                         bytes-0.15.4:Data.Bytes.Signed bytes-0.15.4:Data.Bytes.VarInt
                         clock-0.7.2:System.Clock containers-0.5.10.2:Data.IntMap.Internal
                         containers-0.5.10.2:Data.IntSet.Internal
                         containers-0.5.10.2:Data.Map.Internal
                         containers-0.5.10.2:Data.Sequence.Internal
                         containers-0.5.10.2:Data.Set.Internal containers-0.5.10.2:Data.Tree
                         free-5.0.2:Control.Comonad.Cofree
                         free-5.0.2:Control.Comonad.Trans.Cofree
                         free-5.0.2:Control.Monad.Free free-5.0.2:Control.Monad.Trans.Free
                         ghc-boot-th-8.2.2:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.2.2:GHC.LanguageExtensions.Type
                         kan-extensions-5.1:Data.Functor.Day
                         kan-extensions-5.1:Data.Functor.Yoneda lens-4.16.1:Control.Lens.At
                         lens-4.16.1:Control.Lens.Internal.Indexed
                         lens-4.16.1:Control.Lens.Reified lens-4.16.1:Control.Lens.Tuple
                         lens-4.16.1:Control.Lens.Wrapped lens-4.16.1:Control.Lens.Zoom
                         linear-1.20.7:Linear.Affine linear-1.20.7:Linear.Plucker
                         linear-1.20.7:Linear.Quaternion linear-1.20.7:Linear.V
                         linear-1.20.7:Linear.V0 linear-1.20.7:Linear.V1
                         linear-1.20.7:Linear.V2 linear-1.20.7:Linear.V3
                         linear-1.20.7:Linear.V4
                         monad-control-1.0.2.3:Control.Monad.Trans.Control
                         pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         profunctors-5.2.2:Data.Profunctor.Composition
                         profunctors-5.2.2:Data.Profunctor.Rep sdl2-2.4.0.1:SDL.Audio
                         sdl2-2.4.0.1:SDL.Event sdl2-2.4.0.1:SDL.Exception
                         sdl2-2.4.0.1:SDL.Hint sdl2-2.4.0.1:SDL.Init
                         sdl2-2.4.0.1:SDL.Input.GameController
                         sdl2-2.4.0.1:SDL.Input.Joystick sdl2-2.4.0.1:SDL.Input.Keyboard
                         sdl2-2.4.0.1:SDL.Input.Keyboard.Codes sdl2-2.4.0.1:SDL.Input.Mouse
                         sdl2-2.4.0.1:SDL.Internal.Types sdl2-2.4.0.1:SDL.Power
                         sdl2-2.4.0.1:SDL.Time sdl2-2.4.0.1:SDL.Video
                         sdl2-2.4.0.1:SDL.Video.OpenGL sdl2-2.4.0.1:SDL.Video.Renderer
                         sdl2-ttf-2.0.2:SDL.Font tagged-0.8.5:Data.Tagged
                         template-haskell-2.12.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.0:Data.Text text-1.2.3.0:Data.Text.Lazy
                         th-abstraction-0.2.6.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Storable
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.10.1.0:Control.Monad ebed2e8e7444944e0c1d827c6faf40a4
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  linear-1.20.7:Linear.Affine f4ed1aa58b28d63beac82829593554b3
import  -/  linear-1.20.7:Linear.V2 ee409e3e067ada9faf9fdda331749bf4
import  -/  Aabb 02207cce2d794346ceccf4ae11a9988d
  exports: 74498893d79e07cfc6b7864a88f8a517
  Aabb d17fcb637a1ff42f123a8d7e03514c43
  Aabb 4bc4d1c45ad2d3871f1050d664e236c2
  aabbToRectangle a013c5a0e0aff215b89a8afb6e04557e
  rectangleToAabb 4601f07974c6b4c563a1e869ff1fdd84
import  -/  GameVars c97b478d52eb65df6d94cfdf494ea2ce
  exports: 54748b09c2a15e9d35b796e54eb1daea
import  -/  GuiTransforms e2db9ba277a4f977ddcd90a5635f8391
  exports: f9dcd83a9df04834bf7cc3c940782a98
  GuiTransforms 2fd14cc1a80d141e758ca9f9f3e06ff8
  alignToBottomEdge ea64d8fea0c0cb55c5f764de5ce999a4
  alignToLeftEdge 1cb42eda8238cfd28aadce17377c7db4
  alignToRightEdge a598b5af1e208bb665b4cf1fce71c7db
  translate 8df0f20a9af8b27115b4172f5904e382
  xCenterRectangle ccf03f990a1933f6a7c163f17a0dcfa4
  yCenterRectangle 7bb5678d2589e5a23628d1b6000717a2
import  -/  Logger 8440c95053026489c9281e4e9e175c09
  exports: c7f6c47792388de1970a4c43887f8fdc
import  -/  Util 04dd18c408cec1d861350946bb6e7df1
  exports: 01755414b1287618f45750309b35edae
import  -/  mtl-2.2.2:Control.Monad.Reader 8d63edf5dfaf25ad085eae4468bdd77e
import  -/  mtl-2.2.2:Control.Monad.State.Lazy 1fd6277cc7a06432c7f008ae6678f387
import  -/  sdl2-2.4.0.1:SDL 24b907aeafb5c6d95ad8ce8f19ccd6b3
import  -/  sdl2-2.4.0.1:SDL.Video.Renderer 05fa9f919fc1b42de89d6ed9d3439937
import  -/  transformers-0.5.2.0:Control.Monad.Trans.Reader cc12564dc0d2121844a0316ee821dfff
3993826baf2ac7e51ac52a783c262c6a
  $tc'ButtonAttr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7523112745971044941##
                   3754914807203020998##
                   Buttons.$trModule
                   Buttons.$tc'ButtonAttr2
                   0#
                   Buttons.$tc'ButtonAttr1) -}
63cd1bc37231236a9b0cd4111a6a5cc4
  $tc'ButtonAttr1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
3dbe1e8a9c3e2164233f4497536e5d52
  $tc'ButtonAttr2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Buttons.$tc'ButtonAttr3) -}
1d879970e3deb0efc95adbbe53e7d4d1
  $tc'ButtonAttr3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ButtonAttr"#) -}
a85be6fd356f9fdddb290e59260e6aa2
  $tcButtonAttr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15620510443299003024##
                   12493962166309484681##
                   Buttons.$trModule
                   Buttons.$tcButtonAttr1
                   0#
                   GHC.Types.krep$*) -}
5fe79ee651028329e31ff66c110d7327
  $tcButtonAttr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Buttons.$tcButtonAttr2) -}
3e4ce5b2e99724e1b68dfc5442ec32e7
  $tcButtonAttr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ButtonAttr"#) -}
10bd5d6da2b66a9f59e700a477ea9c03
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Buttons.$trModule3
                   Buttons.$trModule1) -}
a81a2eec69c07bc79b29d9a5c65281e9
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Buttons.$trModule2) -}
73b4fca6efac0900fcc2bd166317f296
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Buttons"#) -}
7cee47401681493a0279792c36fa25bb
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Buttons.$trModule4) -}
7dcc50c55e3ff10675597fb7a5455a6e
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
ed42b97136823455baa17e14617cf2b4
  type Button (m :: * -> *) =
    Control.Monad.Trans.Reader.ReaderT Buttons.ButtonAttr m ()
6b0715224ad83cf733833a908fe45de8
  data ButtonAttr
    = ButtonAttr {rect :: SDL.Video.Renderer.Rectangle GHC.Types.Float,
                  aabb :: Aabb.Aabb,
                  texture :: SDL.Video.Renderer.Texture}
6b0715224ad83cf733833a908fe45de8
  aabb :: Buttons.ButtonAttr -> Aabb.Aabb
  RecSel Left Buttons.ButtonAttr
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSL),1*U(A,1*U(U,U,U,U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Buttons.ButtonAttr) ->
                 case ds of wild { Buttons.ButtonAttr ds1 ds2 ds3 -> ds2 }) -}
f595479cd76915c6c3dd89987e7782ec
  alignToBottomEdgeButtonAttr ::
    GuiTransforms.GuiTransforms m =>
    Buttons.ButtonAttr -> m Buttons.ButtonAttr
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLLLLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),A,A,A,A,1*C1(U),A)><L,U(1*U,A,U)>,
     Unfolding: (\ @ m :: * -> *
                   ($dGuiTransforms :: GuiTransforms.GuiTransforms m)
                   (eta :: Buttons.ButtonAttr) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = GuiTransforms.$p1GuiTransforms @ m $dGuiTransforms
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (SDL.Video.Renderer.Rectangle GHC.Types.Float)
                   @ Buttons.ButtonAttr
                   (GuiTransforms.alignToBottomEdge
                      @ m
                      $dGuiTransforms
                      (case eta of wild { Buttons.ButtonAttr ds ds1 ds2 -> ds }))
                   (\ (rectangle' :: SDL.Video.Renderer.Rectangle GHC.Types.Float) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ Buttons.ButtonAttr
                      (case eta of wild { Buttons.ButtonAttr ds ds1 ds2 ->
                       Buttons.ButtonAttr
                         rectangle'
                         (case rectangle' of ww { SDL.Video.Renderer.Rectangle ww1 ww2 ->
                          case ww1
                                 `cast`
                               (Linear.Affine.N:Point[0]
                                    <Linear.V2.V2>_R <GHC.Types.Float>_N) of ww3 { Linear.V2.V2 ww4 ww5 ->
                          case ww4 of ww6 { GHC.Types.F# ww7 ->
                          case ww5 of ww8 { GHC.Types.F# ww9 ->
                          case ww2 of ww10 { Linear.V2.V2 ww11 ww12 ->
                          case ww11 of ww13 { GHC.Types.F# ww14 ->
                          case ww12 of ww15 { GHC.Types.F# ww16 ->
                          Aabb.Aabb
                            ww6
                            ww8
                            (GHC.Types.F# (GHC.Prim.plusFloat# ww7 ww14))
                            (GHC.Types.F# (GHC.Prim.plusFloat# ww9 ww16)) } } } } } } })
                         ds2 }))) -}
f9d183ab69418b488c241643f6f47e15
  alignToLeftEdgeButtonAttr ::
    GuiTransforms.GuiTransforms m =>
    Buttons.ButtonAttr -> m Buttons.ButtonAttr
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLLLLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),A,A,1*C1(U),A,A,A)><L,U(1*U,A,U)>,
     Unfolding: (\ @ m :: * -> *
                   ($dGuiTransforms :: GuiTransforms.GuiTransforms m)
                   (eta :: Buttons.ButtonAttr) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = GuiTransforms.$p1GuiTransforms @ m $dGuiTransforms
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (SDL.Video.Renderer.Rectangle GHC.Types.Float)
                   @ Buttons.ButtonAttr
                   (GuiTransforms.alignToLeftEdge
                      @ m
                      $dGuiTransforms
                      (case eta of wild { Buttons.ButtonAttr ds ds1 ds2 -> ds }))
                   (\ (rectangle' :: SDL.Video.Renderer.Rectangle GHC.Types.Float) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ Buttons.ButtonAttr
                      (case eta of wild { Buttons.ButtonAttr ds ds1 ds2 ->
                       Buttons.ButtonAttr
                         rectangle'
                         (case rectangle' of ww { SDL.Video.Renderer.Rectangle ww1 ww2 ->
                          case ww1
                                 `cast`
                               (Linear.Affine.N:Point[0]
                                    <Linear.V2.V2>_R <GHC.Types.Float>_N) of ww3 { Linear.V2.V2 ww4 ww5 ->
                          case ww4 of ww6 { GHC.Types.F# ww7 ->
                          case ww5 of ww8 { GHC.Types.F# ww9 ->
                          case ww2 of ww10 { Linear.V2.V2 ww11 ww12 ->
                          case ww11 of ww13 { GHC.Types.F# ww14 ->
                          case ww12 of ww15 { GHC.Types.F# ww16 ->
                          Aabb.Aabb
                            ww6
                            ww8
                            (GHC.Types.F# (GHC.Prim.plusFloat# ww7 ww14))
                            (GHC.Types.F# (GHC.Prim.plusFloat# ww9 ww16)) } } } } } } })
                         ds2 }))) -}
ace1049b6d7456d3915cb91568b08b3b
  alignToRightEdgeButtonAttr ::
    GuiTransforms.GuiTransforms m =>
    Buttons.ButtonAttr -> m Buttons.ButtonAttr
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLLLLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),A,A,A,1*C1(U),A,A)><L,U(1*U,A,U)>,
     Unfolding: (\ @ m :: * -> *
                   ($dGuiTransforms :: GuiTransforms.GuiTransforms m)
                   (eta :: Buttons.ButtonAttr) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = GuiTransforms.$p1GuiTransforms @ m $dGuiTransforms
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (SDL.Video.Renderer.Rectangle GHC.Types.Float)
                   @ Buttons.ButtonAttr
                   (GuiTransforms.alignToRightEdge
                      @ m
                      $dGuiTransforms
                      (case eta of wild { Buttons.ButtonAttr ds ds1 ds2 -> ds }))
                   (\ (rectangle' :: SDL.Video.Renderer.Rectangle GHC.Types.Float) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ Buttons.ButtonAttr
                      (case eta of wild { Buttons.ButtonAttr ds ds1 ds2 ->
                       Buttons.ButtonAttr
                         rectangle'
                         (case rectangle' of ww { SDL.Video.Renderer.Rectangle ww1 ww2 ->
                          case ww1
                                 `cast`
                               (Linear.Affine.N:Point[0]
                                    <Linear.V2.V2>_R <GHC.Types.Float>_N) of ww3 { Linear.V2.V2 ww4 ww5 ->
                          case ww4 of ww6 { GHC.Types.F# ww7 ->
                          case ww5 of ww8 { GHC.Types.F# ww9 ->
                          case ww2 of ww10 { Linear.V2.V2 ww11 ww12 ->
                          case ww11 of ww13 { GHC.Types.F# ww14 ->
                          case ww12 of ww15 { GHC.Types.F# ww16 ->
                          Aabb.Aabb
                            ww6
                            ww8
                            (GHC.Types.F# (GHC.Prim.plusFloat# ww7 ww14))
                            (GHC.Types.F# (GHC.Prim.plusFloat# ww9 ww16)) } } } } } } })
                         ds2 }))) -}
8bf2d1747268e19c5d2d485c6615c650
  createButtonAttrFromAabb ::
    Aabb.Aabb -> SDL.Video.Renderer.Texture -> Buttons.ButtonAttr
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(U),U(U),U(U),U(U))><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (aabb1 :: Aabb.Aabb) (texture1 :: SDL.Video.Renderer.Texture) ->
                 Buttons.ButtonAttr (Aabb.aabbToRectangle aabb1) aabb1 texture1) -}
effc2f988a97d22156f9ef2481c83619
  createButtonAttrFromRectangle ::
    SDL.Video.Renderer.Rectangle GHC.Types.Float
    -> SDL.Video.Renderer.Texture -> Buttons.ButtonAttr
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(U(U),U(U)),U(U(U),U(U)))><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (nrect :: SDL.Video.Renderer.Rectangle GHC.Types.Float)
                   (texture1 :: SDL.Video.Renderer.Texture) ->
                 Buttons.ButtonAttr nrect (Aabb.rectangleToAabb nrect) texture1) -}
c09a1414775e4423cbf66a7e93d1aa86
  createCenteredButtonAttr ::
    GuiTransforms.GuiTransforms m =>
    Linear.V2.V2 GHC.Types.Float
    -> SDL.Video.Renderer.Texture -> m Buttons.ButtonAttr
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLLLLL),U(U(A,C(C1(U)),A,C(U),A),C(U),C(U),A,A,A,A)><L,U><L,U>,
     Unfolding: (\ @ m :: * -> *
                   ($dGuiTransforms :: GuiTransforms.GuiTransforms m)
                   (eta :: Linear.V2.V2 GHC.Types.Float)
                   (eta1 :: SDL.Video.Renderer.Texture) ->
                 GHC.Base.>>=
                   @ m
                   (GuiTransforms.$p1GuiTransforms @ m $dGuiTransforms)
                   @ Buttons.ButtonAttr
                   @ Buttons.ButtonAttr
                   (Buttons.yCenterButtonAttr
                      @ m
                      $dGuiTransforms
                      (Buttons.ButtonAttr
                         (SDL.Video.Renderer.Rectangle
                            @ GHC.Types.Float
                            Buttons.createCenteredButtonAttr3
                              `cast`
                            (Sym (Linear.Affine.N:Point[0]
                                      <Linear.V2.V2>_R) <GHC.Types.Float>_N)
                            eta)
                         Buttons.createCenteredButtonAttr1
                         eta1))
                   (Buttons.xCenterButtonAttr @ m $dGuiTransforms)) -}
02df6c34eac0950aafc589f907431739
  createCenteredButtonAttr1 :: Aabb.Aabb
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Aabb.Aabb
                   Buttons.createCenteredButtonAttr2
                   Buttons.createCenteredButtonAttr2
                   Buttons.createCenteredButtonAttr2
                   Buttons.createCenteredButtonAttr2) -}
0fee9c3b4c562a9cb17e529d7e1fab46
  createCenteredButtonAttr2 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 0.0#) -}
53404395df73592ffb38fc611b58fc38
  createCenteredButtonAttr3 :: Linear.V2.V2 GHC.Types.Float
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Linear.V2.V2
                   @ GHC.Types.Float
                   Buttons.createCenteredButtonAttr2
                   Buttons.createCenteredButtonAttr2) -}
650b31c7d79d4922d97b3d11602308d3
  createLeftEdgeAlignedButtonAttr ::
    GuiTransforms.GuiTransforms m =>
    GHC.Types.Float
    -> Linear.V2.V2 GHC.Types.Float
    -> SDL.Video.Renderer.Texture
    -> m Buttons.ButtonAttr
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLLLLL),U(U(A,C(C1(U)),A,C(U),A),A,A,C(U),A,A,A)><L,1*U(U)><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   ($dGuiTransforms :: GuiTransforms.GuiTransforms m)
                   (ypos :: GHC.Types.Float)
                   (lengths :: Linear.V2.V2 GHC.Types.Float)
                   (texture1 :: SDL.Video.Renderer.Texture) ->
                 Buttons.alignToLeftEdgeButtonAttr
                   @ m
                   $dGuiTransforms
                   (Buttons.ButtonAttr
                      (SDL.Video.Renderer.Rectangle
                         @ GHC.Types.Float
                         (case ypos of dt { GHC.Types.F# ipv ->
                          (Linear.V2.V2
                             @ GHC.Types.Float
                             Buttons.createCenteredButtonAttr2
                             dt)
                            `cast`
                          (Sym (Linear.Affine.N:Point[0]
                                    <Linear.V2.V2>_R) <GHC.Types.Float>_N) })
                         lengths)
                      Buttons.createCenteredButtonAttr1
                      texture1)) -}
4e094196368bedc57f6a35c1e7f21d8b
  createRightEdgeAlignedButtonAttr ::
    GuiTransforms.GuiTransforms m =>
    GHC.Types.Float
    -> Linear.V2.V2 GHC.Types.Float
    -> SDL.Video.Renderer.Texture
    -> m Buttons.ButtonAttr
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLLLLL),U(U(A,C(C1(U)),A,C(U),A),A,A,A,C(U),A,A)><L,1*U(U)><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   ($dGuiTransforms :: GuiTransforms.GuiTransforms m)
                   (ypos :: GHC.Types.Float)
                   (lengths :: Linear.V2.V2 GHC.Types.Float)
                   (texture1 :: SDL.Video.Renderer.Texture) ->
                 Buttons.alignToRightEdgeButtonAttr
                   @ m
                   $dGuiTransforms
                   (Buttons.ButtonAttr
                      (SDL.Video.Renderer.Rectangle
                         @ GHC.Types.Float
                         (case ypos of dt { GHC.Types.F# ipv ->
                          (Linear.V2.V2
                             @ GHC.Types.Float
                             Buttons.createCenteredButtonAttr2
                             dt)
                            `cast`
                          (Sym (Linear.Affine.N:Point[0]
                                    <Linear.V2.V2>_R) <GHC.Types.Float>_N) })
                         lengths)
                      Buttons.createCenteredButtonAttr1
                      texture1)) -}
061e2da352970e66dd8b7141731e3a00
  createXCenteredButtonAttr ::
    GuiTransforms.GuiTransforms m =>
    GHC.Types.Float
    -> Linear.V2.V2 GHC.Types.Float
    -> SDL.Video.Renderer.Texture
    -> m Buttons.ButtonAttr
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLLLLL),U(U(A,C(C1(U)),A,C(U),A),C(U),A,A,A,A,A)><L,1*U(U)><L,U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ m :: * -> *
                   ($dGuiTransforms :: GuiTransforms.GuiTransforms m)
                   (ypos :: GHC.Types.Float)
                   (lengths :: Linear.V2.V2 GHC.Types.Float)
                   (texture1 :: SDL.Video.Renderer.Texture) ->
                 Buttons.xCenterButtonAttr
                   @ m
                   $dGuiTransforms
                   (Buttons.ButtonAttr
                      (SDL.Video.Renderer.Rectangle
                         @ GHC.Types.Float
                         (case ypos of dt { GHC.Types.F# ipv ->
                          (Linear.V2.V2
                             @ GHC.Types.Float
                             Buttons.createCenteredButtonAttr2
                             dt)
                            `cast`
                          (Sym (Linear.Affine.N:Point[0]
                                    <Linear.V2.V2>_R) <GHC.Types.Float>_N) })
                         lengths)
                      Buttons.createCenteredButtonAttr1
                      texture1)) -}
6b0715224ad83cf733833a908fe45de8
  rect ::
    Buttons.ButtonAttr -> SDL.Video.Renderer.Rectangle GHC.Types.Float
  RecSel Left Buttons.ButtonAttr
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U(U,U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Buttons.ButtonAttr) ->
                 case ds of wild { Buttons.ButtonAttr ds1 ds2 ds3 -> ds1 }) -}
6b0715224ad83cf733833a908fe45de8
  texture :: Buttons.ButtonAttr -> SDL.Video.Renderer.Texture
  RecSel Left Buttons.ButtonAttr
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Buttons.ButtonAttr) ->
                 case ds of wild { Buttons.ButtonAttr ds1 ds2 ds3 -> ds3 }) -}
953f609e835bb610b2b81ecd8b9bfde9
  translateButtonAttr ::
    Linear.V2.V2 GHC.Types.Float
    -> Buttons.ButtonAttr -> Buttons.ButtonAttr
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(U(U),U(U))><S,1*U(1*U(1*U(U(U),U(U)),U(U(U),U(U))),A,U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Linear.V2.V2 GHC.Types.Float)
                   (w1 :: Buttons.ButtonAttr) ->
                 case w1 of ww { Buttons.ButtonAttr ww1 ww2 ww3 ->
                 let {
                   nrect :: SDL.Video.Renderer.Rectangle GHC.Types.Float
                   = case w of ww4 { Linear.V2.V2 ww5 ww6 ->
                     case ww5 of ww7 { GHC.Types.F# ww8 ->
                     case ww6 of ww9 { GHC.Types.F# ww10 ->
                     case ww1 of ww11 { SDL.Video.Renderer.Rectangle ww12 ww13 ->
                     case ww12
                            `cast`
                          (Linear.Affine.N:Point[0]
                               <Linear.V2.V2>_R <GHC.Types.Float>_N) of ww14 { Linear.V2.V2 ww15 ww16 ->
                     case ww15 of ww17 { GHC.Types.F# ww18 ->
                     case ww16 of ww19 { GHC.Types.F# ww20 ->
                     SDL.Video.Renderer.Rectangle
                       @ GHC.Types.Float
                       (Linear.V2.V2
                          @ GHC.Types.Float
                          (GHC.Types.F# (GHC.Prim.plusFloat# ww8 ww18))
                          (GHC.Types.F# (GHC.Prim.plusFloat# ww10 ww20)))
                         `cast`
                       (Sym (Linear.Affine.N:Point[0]
                                 <Linear.V2.V2>_R) <GHC.Types.Float>_N)
                       ww13 } } } } } } }
                 } in
                 Buttons.ButtonAttr nrect (Aabb.rectangleToAabb nrect) ww3 }) -}
33a57e656f74d9a0dd45d364394e2426
  xCenterButtonAttr ::
    GuiTransforms.GuiTransforms m =>
    Buttons.ButtonAttr -> m Buttons.ButtonAttr
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLLLLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),1*C1(U),A,A,A,A,A)><L,U(1*U,A,U)>,
     Unfolding: (\ @ m :: * -> *
                   ($dGuiTransforms :: GuiTransforms.GuiTransforms m)
                   (eta :: Buttons.ButtonAttr) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = GuiTransforms.$p1GuiTransforms @ m $dGuiTransforms
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (SDL.Video.Renderer.Rectangle GHC.Types.Float)
                   @ Buttons.ButtonAttr
                   (GuiTransforms.xCenterRectangle
                      @ m
                      $dGuiTransforms
                      (case eta of wild { Buttons.ButtonAttr ds ds1 ds2 -> ds }))
                   (\ (rectangle' :: SDL.Video.Renderer.Rectangle GHC.Types.Float) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ Buttons.ButtonAttr
                      (case eta of wild { Buttons.ButtonAttr ds ds1 ds2 ->
                       Buttons.ButtonAttr
                         rectangle'
                         (case rectangle' of ww { SDL.Video.Renderer.Rectangle ww1 ww2 ->
                          case ww1
                                 `cast`
                               (Linear.Affine.N:Point[0]
                                    <Linear.V2.V2>_R <GHC.Types.Float>_N) of ww3 { Linear.V2.V2 ww4 ww5 ->
                          case ww4 of ww6 { GHC.Types.F# ww7 ->
                          case ww5 of ww8 { GHC.Types.F# ww9 ->
                          case ww2 of ww10 { Linear.V2.V2 ww11 ww12 ->
                          case ww11 of ww13 { GHC.Types.F# ww14 ->
                          case ww12 of ww15 { GHC.Types.F# ww16 ->
                          Aabb.Aabb
                            ww6
                            ww8
                            (GHC.Types.F# (GHC.Prim.plusFloat# ww7 ww14))
                            (GHC.Types.F# (GHC.Prim.plusFloat# ww9 ww16)) } } } } } } })
                         ds2 }))) -}
2ba43a51eb4b630e55d03e14316c7765
  yCenterButtonAttr ::
    GuiTransforms.GuiTransforms m =>
    Buttons.ButtonAttr -> m Buttons.ButtonAttr
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(C(S))LLL)LLLLLL),U(1*U(A,1*C1(C1(U)),A,C(U),A),A,1*C1(U),A,A,A,A)><L,U(1*U,A,U)>,
     Unfolding: (\ @ m :: * -> *
                   ($dGuiTransforms :: GuiTransforms.GuiTransforms m)
                   (eta :: Buttons.ButtonAttr) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = GuiTransforms.$p1GuiTransforms @ m $dGuiTransforms
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (SDL.Video.Renderer.Rectangle GHC.Types.Float)
                   @ Buttons.ButtonAttr
                   (GuiTransforms.yCenterRectangle
                      @ m
                      $dGuiTransforms
                      (case eta of wild { Buttons.ButtonAttr ds ds1 ds2 -> ds }))
                   (\ (rectangle' :: SDL.Video.Renderer.Rectangle GHC.Types.Float) ->
                    GHC.Base.return
                      @ m
                      $dMonad
                      @ Buttons.ButtonAttr
                      (case eta of wild { Buttons.ButtonAttr ds ds1 ds2 ->
                       Buttons.ButtonAttr
                         rectangle'
                         (case rectangle' of ww { SDL.Video.Renderer.Rectangle ww1 ww2 ->
                          case ww1
                                 `cast`
                               (Linear.Affine.N:Point[0]
                                    <Linear.V2.V2>_R <GHC.Types.Float>_N) of ww3 { Linear.V2.V2 ww4 ww5 ->
                          case ww4 of ww6 { GHC.Types.F# ww7 ->
                          case ww5 of ww8 { GHC.Types.F# ww9 ->
                          case ww2 of ww10 { Linear.V2.V2 ww11 ww12 ->
                          case ww11 of ww13 { GHC.Types.F# ww14 ->
                          case ww12 of ww15 { GHC.Types.F# ww16 ->
                          Aabb.Aabb
                            ww6
                            ww8
                            (GHC.Types.F# (GHC.Prim.plusFloat# ww7 ww14))
                            (GHC.Types.F# (GHC.Prim.plusFloat# ww9 ww16)) } } } } } } })
                         ds2 }))) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

